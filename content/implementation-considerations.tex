\chapter{Consideraciones sobre la implementación}

\section{Visión general}

	En este capítulo se recogen las reglas de estilo seguidas a la hora de codificar el proyecto, así como una descripción y justificación de las herramientas utilizadas para la realización del mismo. Por último, se explica cómo han sido llevados a cabo los apartados más destacables del desarrollo del juego.

\section{Reglas de estilo}

	A pesar de que no existe un estándar oficial para escribir código, hay numerosas guías de estilo y mejores prácticas que son usadas por la mayoría de la comunidad de programadores. Estas guías suelen estar agrupadas por lenguaje de programación y facilitan la lectura, modificación y comprensión de código ajeno, y al mismo tiempo sirven de buenas prácticas.

	\begin{itemize}
		\item El código estará escrito y comentado en inglés, con la intención de hacerlo lo más universal posible.

		\item Todos los archivos fuente estarán codificados en \acrshort{utf}-8, para permitir el uso de carácteres especiales.

		\item Los nombres de los archivos comenzarán en mayúsculas, para separar palabras se escribirá la primera letra de cada una en mayúsculas.

		\item Los nombres de las variables y funciones estarán escritos en minúscula, para separar palabras se escribirá la primera letra de cada una en mayúsculas, empezando por la segunda.

		\item Se darán nombres descriptivos a las variables, funciones y archivos.

		\item Inmediatamente antes de la cabecera de cada función se comentará su funcionalidad, así como la especificación de sus parámetros de entrada y el resultado de su salida.

		\item Cualquier otra clarificación de fragmentos de código será debidamente comentada.
	\end{itemize}

\section{Entorno de desarrollo}

	Para el desarrollo del proyecto se han utilizado varias herramientas para facilitar la codificación, compilación y búsqueda de errores.

	\subsection{Atom}

		Atom es un editor de texto desarrollado por Github. Es una herramienta que permite personalizar cualquier cosa, pero también permite ser usada productivamente sin tocar ningún archivo de configuración. Atom ofrece integración con Node.js y está diseñado de forma completamente modular, de forma que es posible acoplar un número indefinido de módulos a su núcleo mínimo. Además, su versión más mínima ya dispone de todas las características necesarias para empezar a trabajar. Por último, Atom es de código libre y, por tanto, gratuito.

		\begin{figure}[!htp]
			 \centering
			 \includegraphics[scale=.15]{fig/atom}
			 \caption{Logotipo de Atom}
			 \label{fig:atom}
		\end{figure}

		\FloatBarrier

		Este software ha sido la herramienta principal para el proyecto. Ha sido utilizada para la codificación de todo el proyecto, para el retoque de los archivos \acrshort{json} y para la generación de los archivos de configuración necesarios. Cualquier editor de texto sencillo podría haber sido utilizado, pero se ha optado por Atom ya que provee características avanzadas para codificar, tales como soporte para distintos lenguajes, que además pueden ser ampliadas mediante módulos gratuitos.

	\subsection{\acrlong{gcc}}

		El \acrfull{gcc} es un conjunto de compiladores creados por el proyecto \acrshort{gnu}. \acrshort{gcc} es software libre y lo distribuye la \acrshort{fsf} bajo la licencia general pública GPL.

		Estos compiladores se consideran estándar para los sistemas operativos derivados de UNIX, de código abierto y tambiñen de propietarios, como Mac OS X. \acrshort{gcc} requiere el conjunto de aplicaciones conocido como \textit{binutils} para realizar tareas como identificar archivos objeto u obtener su tamaño para copiarlos, traducirlos o crear listas, enlazarlos, o quitarles símbolos innecesarios.

		Originalmente \acrshort{gcc} solo compilaba C, pero posteriormente se extendió para compilar C++, Fortran, Ada y otros.

		\begin{figure}[!htp]
			 \centering
			 \includegraphics[scale=.25]{fig/gcc}
			 \caption{Logotipo de \acrshort{gcc}}
			 \label{fig:gcc}
		\end{figure}

		\FloatBarrier

		Se ha decidido utilizar este compilador ya que, además de ser gratuito, es el estándar para muchas plataformas, de forma que su fiabilidad es muy alta.

	\subsection{Git}

		Git es un software de control de versiones diseñado por Linus Torvalds pensando en la eficiencia y la confiabilidad del mantenimiento de versiones de aplicaciones cuando estas tienen un gran número de archivos de código fuente. Al principio, Git se pensó como un motor de bajo nivel sobre el cual otros pudieran escribir interfaces de usuario. Sin embargo, Git se ha convertido desde entonces en un sistema de control de versiones con funcionalidad plena. Hay algunos proyectos de mucha relevancia que ya usan Git, en particular, el grupo de programación del núcleo Linux.

		\begin{figure}[!htp]
			 \centering
			 \includegraphics[scale=.25]{fig/git}
			 \caption{Logotipo de Git}
			 \label{fig:git}
		\end{figure}

		\FloatBarrier

		Se ha decidido utilizar Git como sistema de control de versiones de entre las muchas opciones disponibles ya que el equipo tenía experiencia previa trabajando con la herramienta. Además, Git ofrece muchas ventajas, es flexible, potente y rápido.

	\subsection{Make}

		Make es una herramienta de gestión de dependencias, típicamente, las que existen entre los archivos que componen código fuente de un programa, para dirigir su recompilación o generación automáticamente. Si bien es cierto que su función bñasica consiste en determinar automáticamente qué partes de un programa requieren ser recompiladas y ejecutar los comandos necesarios para hacerlo, también lo es que Make puede usarse en cualquier escenario en el que se requiera, de alguna forma, actualizar automáticamente un conjunto de archivos a partir de otro, cada vez que éste cambie.

		Make es muy usada en los sistemas operativos tipo Unix/Linux. Por defecto lee las instrucciones para generar el programa u otra acción del ficher Makefile. Las instrucciones escritas en este fichero se llaman dependencias.

		\begin{figure}[!htp]
			 \centering
			 \includegraphics[scale=.25]{fig/make}
			 \caption{Logotipo de Make}
			 \label{fig:make}
		\end{figure}

		\FloatBarrier

		Make ha sido de gran ayuda para el proyecto ya que, al utilizar la librería \acrshort{sfml}, la generación de ejecutables no era directa, eran necesarios dos pasos: compilar y enlazar. En ambos pasos era imprescindible incluir todas las librerías necesarias y especificar unos parámetros concretos. Make ha servido para automatizar estos dos pasos, evitando así múltiples errores.

	\subsection{darkFunction Editor}

		darkFunction Editor es un estudio de gráficos gratuito y de código libre que permite definir matrices gráficas rápidamente y construir animaciones complejas, que pueden ser exportadas como \acrshort{gif} o \acrshort{xml}.

		\begin{figure}[!htp]
			 \centering
			 \includegraphics[scale=.25]{fig/darkF}
			 \caption{Logotipo de darkFunction}
			 \label{fig:darkF}
		\end{figure}

		\FloatBarrier

		Este programa ha sido utilizado para generar archivos \acrshort{xml} que contenían las coordenadas de cada fotograma de animación. Además, también ha creado archivos \acrshort{xml} que definen las animaciones por fotogramas. Esta herramienta ha sido de un valor incalculable, ya que permitía hacer mediante una interfaz gráfica sencilla lo que a mano suponía una carga de trabajo grandísima.

	\subsection{\acrshort{xml} to \acrshort{json}}

		\acrshort{xml} to \acrshort{json} es una sencilla aplicación web que permite convertir al instante y de forma gratuita archivos \acrshort{xml} a \acrshort{json} y viceversa. Está alojada en una web mantenida por Osys.

		Esta herramienta ha sido utilizada en el proyecto para convertir los archivos \acrshort{xml} generados por la aplicación previamente mencionada en archivos \acrshort{json}, que serían los después utilizados por el producto.

	\subsection{\acrshort{gimp}}

		\acrfull{gimp} es un programa de edición de imágenes digitales en forma de mapa de bits, tanto dibujos como fotografías. Es un programa libre y gratuito. Forma parte del proyecto \acrshort{gnu} y está disponible bajo la licencia pública general de \acrshort{gnu}. Es el programa de manipulación de gráficos disponible en más sistemas operativos.

		\acrshort{gimp} tiene herramientas que se utilizan para el retoque y edición de imágenes, dibujo de formas libres, cambiar el tamaño, recortar, hacer fotomontajes, convertir a diferentes formatos de imagen, y otras tareas más especializadas. Se pueden también crear imágenes animadas en formato \acrshort{gif} e imágenes animadas en formato \acrshort{mpeg} usando un plugin de animación.

		\begin{figure}[!htp]
			 \centering
			 \includegraphics[scale=.15]{fig/gimp}
			 \caption{Logotipo de \acrshort{gimp}}
			 \label{fig:gimp}
		\end{figure}

		\FloatBarrier

		Este programa se ha utilizado para editar las imágenes que se han utilizado en el juego. Se ha decidido utilizar esta herramienta por ser la mejor de su condición entre todas las opciones gratuitas.

\section{Desarrollo del juego}

	\subsection{Animaciones}

		Todos los personajes del juego cuentan con una animación visual distinta para cada acción que realizan, ya sea moverse, atacar o usar alguna habilidad. Para animarlos, es necesario contar con una imagen estática para cada paso de la animación y después pintarlas en la secuencia correcta mediante algoritmia.

		Estas imágenes pueden estar en dos formatos distintos: cada una en un fichero o todas juntas en el mismo, lo cual se denomina matriz de imágenes. Las segundas son mucho más usadas ya que las operaciones de carga de ficheros son lentas y costosas, de forma que es mucho más eficiente cargar una sola imágen que varias, aún cuando el tamaño de esta es grande.

		El inconveniente que tienen las matrices de imágenes es que la complejidad de los algoritmos de pintado aumenta, ya que no es suficiente simplemente con dibujar la imagen entera en el momento correcto, sino que es necesario dibujar un pedazo concreto de la imagen en un momento concreto. Cada uno de estos pedazo corresponde a cada paso de las animaciones, y pueden ser de tamaño variable entre sí.

		Hay que hacerle saber al programa cuáles son las coordenadas y el tamaño de cada pedazo, y existen dos formas de hacerlo: introduciendo los datos a mano, lo cual es muy costoso e inconveniente en caso de necesidad de modificación, o leerlas de un archivo. En este caso, se ha optado por utilizar archivos \acrshort{json} para almacenar las coordenadas de las imágenes y la definición de animaciones.

		Estos archivos han sido generados a partir de los archivos \acrshort{xml} proporcionados por el programa darkFunction Editor. Para la conversión de \acrshort{xml} a \acrshort{json}, se ha utilizado la aplicación web \acrshort{xml} to \acrshort{json}.

		A continuación se muestran las estructura de los archivos \acrshort{json} que contiene animaciones y coordenadas.

		\begin{center}
		\begin{minipage}{.6\textwidth}
		\begin{lstlisting}[caption={Estructura de las animaciones en \acrshort{json}},label={lst:animjson},language=Python]
{
  "img": {
    "-name": "6369.png",
    "-w": "1208",
    "-h": "3736",
    "definitions": {
      "dir": {
        "-name": "Link",
        "dir": [
          {
            "-name": "Idle",
            "dir": [
              {
                "-name": "Down",
                "spr": {
                  "-name": "0",
                  "-x": "15",
                  "-y": "9",
                  "-w": "18",
                  "-h": "23"
                }
              },
              {
                "-name": "Left",
                "spr": {
		\end{lstlisting}
		\end{minipage}
		\end{center}

		Como se puede ver, el archivo de animaciones contiene el nombre del archivo de coordenadas y una lista de animaciones. Cada animación cuenta con un nombre y una lista de celdas. Las celdas contienen la ruta de las coordenadas que corresponden al paso de animación que se desea. El resto de datos que se pueden observar en la figura no se utilizan, simplemente están ahí porque los generaba darkFunction Editor.

		Por otro lado, el archivo de coordenadas contiene el nombre de la imagen de la que se deben extraer las celdas, así como el valor de su altura y anchura. Tras esto, contiene el nombre de la entidad y una lista de estados. Los archivos contienen un estado por cada acción que puede realizar el personaje. Como la visualización de cada estado varía en función de la dirección en la que se ejecute, cada estado contiene una lista para cada dirección: arriba, abajo e izquierda. La derecha se consigue volteando las imágenes en tiempo de ejecución. Por último, cada dirección contiene una lista de coordenadas. Cada coordenada tiene un número de identificación y cuatro parámetros: la coordenada en el eje horizontal, la coordenada en el eje vertical, la altura y la anchura. El resto de datos no se utilizan, pero existen porque fueron generados por darkFunction Editor.

		El funcionamiento del algortimo es en realidad bastante sencillo. Recibe el nombre del archivo de animaciones, lo carga. De él extrae el nombre del archivo de coordenadas y lo carga también. A continuación, genera un objeto de animación por cada entrada en la lista de animaciones del primer \acrshort{json}. Para ello, va leyendo la lista de celdas de cada animación la ruta de las coordenadas. Por último, se dirige al archivo de coordenadas y busca en el árbol \acrshort{json} el objeto existente el dicha ruta, y extrae los parámetros necesarios.

	\subsection{Generación de mapas}

		Como ya se ha definido, uno de los requisitos del proyecto era que el mapa del juego fuese generado proceduralmente. Para ello, se investigaron diferentes técnicas y algoritmos con este propósito, y, tras barajar distintas posibilidades, se optó por el siguiente algoritmo, denominado \textit{Drunkard's walk}.

		Este es un sencillo algoritmo que se puede utilizar para generar terrenos cuadriculados. Generar un escenario con una sola ejecución del algoritmo garantiza que el nivel estará completamente conectado, con una mezcla de espacios abiertos y estrechos muy variable.

		A continuación se definen los pasos básicos del algoritmo:

		\begin{itemize}

			\item Inicializar todas las celdas del mapa como infranqueables.

			\item Seleccionar una celda del mapa aleatoriamente.

			\item Convertir esa celda en navegable.

			\item Mientras no se haya llegado al número de navegables estipulado:

			\begin{itemize}

				\item Moverse una celda en una dirección aleatoria.

				\item Si la celda es infranqueable, volverla navegable y actualizar número de navegables.

			\end{itemize}

		\end{itemize}

		Para resultados óptimos, el algoritmo requiere que el mapa pueda ser redimensionado dinámicamente, de forma que se evite que los niveles toquen los límites con resultados insatisfactorios. Sin embargo, se le han hecho unos ajustes al algoritmo para adaptarlo a las necesidades y deseos del proyecto.

		En primer lugar, el mapa no se redimensiona, el generador recibe una altura y una anchura que no varían. Para evitar el problema citado anteriormente, se ha impuesto la restricción de que el algoritmo debe dejar al menos dos celdas como infranqueables en cada límite.

		Con esto ya se conseguía un mapa para la partida, pero en los videojuegos, la escenografía juega un papel muy importante en la experiencia de usuario, de forma que era necesario hacer el ambiente visualmente agradable. Para ello, se decidió que el entorno sería una isla, y se creó un método recursivo que, dadas las coordenadas de una celda infranqueable, marca todas las demás del mismo tipo que sean colindantes a ella, y después hace lo mismo con las marcadas. De esta manera, se puede marcar cada conjunto aislado de celdas no navegables.

		Este método se aplica sobre la celda en el eje de las coordenadas, de forma que quedan marcadas todas las celdas que rodean a las celdas navegables. Tras esto, se aplican una serie de sencillos algoritmos que sustituyen las gráficas de las celdas marcadas por distintas gráficas de agua, dando la sensación de isla.

	\subsection{Sistemas de estados para entidades}

		//WIP

	\subsection{IA enemiga}

		//WIP

	\subsection{Gestión de escenas}

		//WIP
